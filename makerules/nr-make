#!/bin/bash
# ===============================================================
# This is a make file generator for the nr-make system.
# ===============================================================

# ===============================================================
# Utility functions
# ===============================================================
error() {
    echo -e >&2 "error: $@"
    exit 1
}

check() {
    local code=$?
    (( code > 0 )) && error "$@"
    return 0
}

assert_non_empty() {
    local __var="$1"; local __val
    eval "__val=\$${__var}"
    [[ "$__val" ]]; check "$__var is empty"
}

log() { echo -e "[LOG] $@"; }

msg() { echo -n -e "$@"; }

log_var() {
    eval "local __v=\${$1}"
    spaces=" "
    if [[ "$__v" =~ $spaces ]]; then
        log "$1=\"$__v\""
    else
        log "$1=$__v"
    fi
}

# This is a readlink that  will  return the resolved and absolute
# path of a file or pointed to by a link  in  a  way  that  works
# across Unix variants.
readlink_abs_compat() {
    file="$1"
    # We could have links pointing to  links, so need to keep re-
    # solving until that's not the case.
    while test -L "$file"; do
        file="$(readlink "$file")"
    done
    # Get folder/basename
    echo "$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
}

# ===============================================================
# Create the  top-level  symlink  from  Makefile  -->  nr-make.mk
# ===============================================================
makefile_link() {
    this="$1"; shift
    root="$1"; shift
    [[ ! -e "$root" ]] && {
        mkdir -p "$root" || error "failed to create $root" 
    }
    [[ -d "$root" ]] || error "root $root not a directory"
    [[ -e "$root"/Makefile ]] &&
        error "$root/Makefile already exists"
    # Should finally be safe to create the link
    ln -s "$this/nr-make.mk" "$root/Makefile" ||
        error "failed to create symlink"
    return 0
}

# ===============================================================
# Some Stub Source Files
# ===============================================================
stub_main='// Generated by nr-make

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello, World!" << endl;
    return 0;
}'

stub_so='// Generated by nr-make

#include <iostream>

using namespace std;

void hello() {
    cout << "Hello, World!" << endl;
}'

# ===============================================================
# Creates a new project
# ===============================================================
init() {
    kind="$1"; shift
    root="$1"; shift
    case "$kind" in
        simple)
            [[ -z "$root" ]] && root="."
            # It  is  safe  to do this now because we should have
            # already checked to make sure we're not being
            # sourced.
            this="$(dirname "$(readlink_abs_compat "$0")")" ||
                error "failed to get abs path of script"
            makefile_link "$this" "$root" || return 2
            # If  there  are  not  c/cpp source files in the root
            # folder then create a stub.
            count="$(ls $root/*.c $root/*.cpp 2>/dev/null | wc -l)"
            if (( count == 0 )); then
                msg "Creating stub main.cpp\n"
                echo "$stub_main" >> "$root/main.cpp" ||
                    error "failed to write stub $stub_main"
            fi
            return $?
        ;;
        standard)
            error "standard mode not yet supported."
        ;;
        *)
            msg "Usage: nr-make init kind\n"
            msg "\n"
            msg "   kind can be: simple\n"
            msg "                standard\n"
            return 1
        ;;
    esac
    # !! Should not get here
    return 1
}

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#                        Make Shared Object
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
stub_makefile='ifndef root
    include $(dir $(lastword $(MAKEFILE_LIST)))../Makefile
else
    # Must enter in order of dependencies.
    locations := # Put any additional sublocations here
    $(call enter_all,$(locations))

    $(call MAKE_WHAT,NAME,NAME)
endif'

new_module() {
    local what="$1"
    local stub="$2"
    local name="$3"
    local folder="$4"
    assert_non_empty what
    assert_non_empty stub
    assert_non_empty name
    assert_non_empty folder
    [[ ! -e "$folder/Makefile" ]]
    check "$folder/Makefile already exists"
    mkdir -p "$folder"
    check "failed to create folder $folder"
    body="$stub_makefile"
    body="${body//NAME/$name}"
    body="${body//MAKE_WHAT/$what}"
    echo "$body" >"$folder/Makefile"
    check "failed to write $folder/Makefile"
    echo "$stub" >"$folder/$name.cpp"
    check "failed to write $folder/$name.cpp"
    # Give the user a list of files we've created.
    echo 'Created:'
    find "$folder"
}

exe()    { new_module make_exe "$stub_main" "$@"; }
shared() { new_module make_so  "$stub_so"   "$@"; }

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#                              Usage
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
usage='
nr-make: project generator

Usage: nr-make mode [...]

    mode can be: init

Example 1. to create a new simple project
           in the current directory:

    $ nr-make init simple

Example 2. to create a new simple project
           in a given folder (which will be
           created if it does not exist):

    $ nr-make init simple path/to/folder

Example 3. to create a shared library in a
           source folder:

    $ nr-make shared name path/to/folder

Example 4. to create an executable in a
           source folder:

    $ nr-make exe name path/to/folder
'

# ===============================================================
# Driver
# ===============================================================
main() {
    mode="$1"; shift

    case "$mode" in
        init)   ;;
        exe)    ;;
        shared) ;;
        *)
            echo "$usage"
            return 1
        ;;
    esac

    # The mode is recognized, so run it.
    $mode "$@"
}

# ===============================================================
# Detect  if we are being sourced, and, if so, return with error.
# ===============================================================
[[ "${BASH_SOURCE[0]}" != "$0" ]] && {
    echo >&2 "This script should not be sourced."
    return 1
}

# ===============================================================
# Go
# ===============================================================
main "$@"
